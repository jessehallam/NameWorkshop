// Generated by IcedCoffeeScript 108.0.11
(function() {
  var CapitalExpression, ConstantExpression, DistinctExpression, EvaluationExpression, ExpressionBase, ExpressionBranch, ExpressionList, ItemExpression, ItemsExpression, Lexer, NameLookupExpression, Parser, RangeExpression, RepeatExpression, getHashCode, getRandom, lexStates,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  getHashCode = function(str) {
    var hval, i, l, _i, _ref;
    i = 0;
    l = 0;
    hval = 0x811c9dc5;
    for (i = _i = 0, _ref = str.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      hval ^= str.charCodeAt(i);
      hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
    }
    return ("0000000" + (hval >>> 0).toString(16)).substr(-8);
  };

  getRandom = function(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  };

  lexStates = {
    start: [
      {
        m: /\(/,
        t: '('
      }, {
        m: /\)/,
        t: ')'
      }, {
        m: /\|/,
        t: '|'
      }, {
        m: /\^/,
        t: '^'
      }, {
        m: /</,
        t: '<',
        next: 'named'
      }, {
        m: /\[/,
        t: '[',
        next: 'range'
      }, {
        m: /\{/,
        t: '{',
        next: 'rep'
      }, {
        m: /\*/,
        t: 'KLEENESTAR'
      }, {
        m: /./,
        t: 'CHAR'
      }
    ],
    named: [
      {
        m: /[a-zA-Z0-9]/,
        t: 'CHAR'
      }, {
        m: /-|_/,
        t: 'ALTCHAR'
      }, {
        m: />/,
        t: '>',
        next: 'start'
      }
    ],
    range: [
      {
        m: /[a-zA-Z0-9]/,
        t: 'CHAR'
      }, {
        m: /-/,
        t: '-'
      }, {
        m: /]/,
        t: ']',
        next: 'start'
      }
    ],
    rep: [
      {
        m: /\d+/,
        t: 'INT'
      }, {
        m: /-/,
        t: '-'
      }, {
        m: /\}/,
        t: '}',
        next: 'start'
      }
    ]
  };

  Lexer = (function() {
    function Lexer(input) {
      this.input = input;
      this.i = 0;
      this.state = 'start';
      this.line = 0;
      this.col = 0;
    }

    Lexer.prototype.readTokens = function() {
      var t, _results;
      _results = [];
      while (t = this.$readNext()) {
        _results.push(t);
      }
      return _results;
    };

    Lexer.prototype.$advancePos = function(s) {
      var c, i, _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = s.length; _i < _len; i = ++_i) {
        c = s[i];
        if (c === '\r') {
          if (c === '\n') {
            this.line++;
            _results.push(this.col = 0);
          } else {
            _results.push(void 0);
          }
        } else if (c === '\n') {
          this.line++;
          _results.push(this.col = 0);
        } else {
          _results.push(this.col++);
        }
      }
      return _results;
    };

    Lexer.prototype.$readNext = function() {
      var r, rule, t, _i, _len, _ref;
      _ref = lexStates[this.state];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        if (this.input.search(rule.m) === 0) {
          r = rule.m.exec(this.input);
          t = {
            tok: rule.t,
            val: r[0],
            match: r,
            pos: [this.line, this.col]
          };
          this.input = this.input.substr(r[0].length);
          if (rule.next) {
            this.state = rule.next;
          }
          return t;
        }
      }
    };

    return Lexer;

  })();

  ExpressionBase = (function() {
    function ExpressionBase() {}

    ExpressionBase.prototype["eval"] = function() {
      return "";
    };

    ExpressionBase.prototype.toString = function() {
      return 'Expression()';
    };

    return ExpressionBase;

  })();

  ConstantExpression = (function(_super) {
    __extends(ConstantExpression, _super);

    function ConstantExpression(chars) {
      var c;
      this.val = !chars ? '' : ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = chars.length; _i < _len; _i++) {
          c = chars[_i];
          _results.push(c.val);
        }
        return _results;
      })()).join('');
    }

    ConstantExpression.prototype["eval"] = function() {
      return this.val;
    };

    ConstantExpression.prototype.toString = function() {
      return "'" + this.val + "'";
    };

    return ConstantExpression;

  })(ExpressionBase);

  ItemExpression = (function(_super) {
    __extends(ItemExpression, _super);

    function ItemExpression() {
      this.item = null;
    }

    ItemExpression.prototype.toString = function() {
      return 'ItemExpresion(' + this.item + ')';
    };

    return ItemExpression;

  })(ExpressionBase);

  CapitalExpression = (function(_super) {
    __extends(CapitalExpression, _super);

    function CapitalExpression(item) {
      this.item = item;
    }

    CapitalExpression.prototype["eval"] = function(context) {
      var val;
      val = this.item["eval"](context);
      if (val) {
        val = val[0].toUpperCase() + val.substr(1);
      }
      return val;
    };

    CapitalExpression.prototype.toString = function() {
      return 'Capital(' + this.item.toString() + ')';
    };

    return CapitalExpression;

  })(ItemExpression);

  ItemsExpression = (function(_super) {
    __extends(ItemsExpression, _super);

    function ItemsExpression() {
      this.items = [];
    }

    ItemsExpression.prototype.toString = function() {
      return 'ItemsExpression(' + this.items.join(', ') + ')';
    };

    return ItemsExpression;

  })(ExpressionBase);

  DistinctExpression = (function(_super) {
    __extends(DistinctExpression, _super);

    function DistinctExpression(item) {
      this.item = item;
    }

    DistinctExpression.prototype["eval"] = function(context) {
      var hash, i;
      hash = this.getHashCode();
      i = context.distinctGroups[hash].indexOf(this);
      if (context.distinctCache[hash] === i) {
        return this.item["eval"](context);
      } else {
        return '';
      }
    };

    DistinctExpression.prototype.getHashCode = function() {
      return getHashCode(this.toString());
    };

    DistinctExpression.prototype.toString = function() {
      return 'DistinctExpression(' + this.item + ')';
    };

    return DistinctExpression;

  })(ItemExpression);

  ExpressionList = (function(_super) {
    __extends(ExpressionList, _super);

    function ExpressionList() {
      return ExpressionList.__super__.constructor.apply(this, arguments);
    }

    ExpressionList.prototype["eval"] = function(context) {
      var item;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = this.items;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          _results.push(item["eval"](context));
        }
        return _results;
      }).call(this)).join('');
    };

    ExpressionList.prototype.toString = function() {
      return 'ExpressionList(' + this.items.join(', ') + ')';
    };

    return ExpressionList;

  })(ItemsExpression);

  ExpressionBranch = (function(_super) {
    __extends(ExpressionBranch, _super);

    function ExpressionBranch() {
      return ExpressionBranch.__super__.constructor.apply(this, arguments);
    }

    ExpressionBranch.prototype["eval"] = function(context) {
      if (!this.items.length) {
        return "";
      }
      return this.items[getRandom(0, this.items.length)]["eval"](context);
    };

    ExpressionBranch.prototype.toString = function() {
      return this.items.join(' | ');
    };

    return ExpressionBranch;

  })(ItemsExpression);

  NameLookupExpression = (function(_super) {
    __extends(NameLookupExpression, _super);

    function NameLookupExpression(name) {
      this.name = name;
    }

    NameLookupExpression.prototype["eval"] = function(context) {
      if (!context[this.name]) {
        return '';
      }
      return context[this.name]["eval"](context);
    };

    NameLookupExpression.prototype.toString = function() {
      return '<' + this.name + '>';
    };

    return NameLookupExpression;

  })(ExpressionBase);

  RangeExpression = (function(_super) {
    __extends(RangeExpression, _super);

    function RangeExpression(min, max) {
      this.min = min.charCodeAt(0);
      this.max = max.charCodeAt(0) + 1;
    }

    RangeExpression.prototype["eval"] = function() {
      return String.fromCharCode(getRandom(this.min, this.max));
    };

    RangeExpression.prototype.toString = function() {
      return 'Range[' + String.fromCharCode(this.min) + ' - ' + String.fromCharCode(this.max - 1) + ']';
    };

    return RangeExpression;

  })(ExpressionBase);

  RepeatExpression = (function(_super) {
    __extends(RepeatExpression, _super);

    function RepeatExpression(expression, repetition) {
      this.expression = expression;
      this.repetition = repetition;
    }

    RepeatExpression.prototype["eval"] = function(context) {
      var count, i, results, _i, _ref;
      count = getRandom(this.repetition.min, this.repetition.max + 1);
      if (count <= 0) {
        return;
      }
      results = [];
      for (i = _i = 0, _ref = count - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        results.push(this.expression["eval"](context));
      }
      return results.join('');
    };

    RepeatExpression.prototype.toString = function() {
      return this.expression.toString() + '{' + this.repetition.min + ' - ' + this.repetition.max + '}';
    };

    return RepeatExpression;

  })(ExpressionBase);

  EvaluationExpression = (function(_super) {
    __extends(EvaluationExpression, _super);

    function EvaluationExpression(item, args) {
      this.item = item;
      this.args = args;
    }

    EvaluationExpression.prototype["eval"] = function(context) {
      var collection, hash, _ref;
      context = context || {
        expressions: {}
      };
      $.extend(context, this.args);
      _ref = context.distinctGroups;
      for (hash in _ref) {
        collection = _ref[hash];
        context.distinctCache[hash] = getRandom(0, collection.length);
      }
      return this.item["eval"](context);
    };

    EvaluationExpression.prototype.toString = function() {
      return this.item.toString();
    };

    return EvaluationExpression;

  })(ItemExpression);

  Parser = (function() {
    function Parser(input) {
      this.input = input;
      this.i = 0;
      this.evalArgs = {
        distinctCache: {},
        distinctGroups: {}
      };
    }

    Parser.prototype.program = function() {
      var r;
      r = this.$readExpressionBranch();
      if (this.$la()) {
        throw new Error('Parse error');
      }
      return new EvaluationExpression(r, this.evalArgs);
    };

    Parser.prototype.$expect = function(name) {
      if (this.$la(0) === name) {
        return this.input[this.i++];
      }
    };

    Parser.prototype.$invalidToken = function(token) {
      token = token || this.input[this.i];
      return new Error('Got `' + (token ? token.tok : '') + '` at ' + (token ? token.pos : 'EOF'));
    };

    Parser.prototype.$la = function(k) {
      if (k == null) {
        k = 0;
      }
      if (this.input[this.i + k]) {
        return this.input[this.i + k].tok;
      }
    };

    Parser.prototype.$readDistinctExpression = function() {
      var exp;
      if (!this.$expect('KLEENESTAR')) {
        return;
      }
      if (!(exp = this.$readExpression())) {
        throw this.$invalidToken();
      }
      if (!this.$expect('KLEENESTAR')) {
        return;
      }
      exp = new DistinctExpression(exp);
      this.evalArgs.distinctGroups[exp.getHashCode()] = this.evalArgs.distinctGroups[exp.getHashCode()] || [];
      this.evalArgs.distinctGroups[exp.getHashCode()].push(exp);
      return exp;
    };

    Parser.prototype.$readExpression = function() {
      var cap, exp, rep;
      cap = this.$expect('^');
      exp = this.$readDistinctExpression() || this.$readRangeExpression() || this.$readNamedExpression() || this.$readGroupExpression() || this.$readConstantExpression();
      if (!exp) {
        return;
      }
      rep = this.$readRepeatExpression();
      if (rep) {
        exp = new RepeatExpression(exp, rep);
      }
      if (cap) {
        exp = new CapitalExpression(exp);
      }
      return exp;
    };

    Parser.prototype.$readConstantExpression = function() {
      var c, results;
      results = [];
      if (!(c = this.$expect('CHAR'))) {
        return;
      }
      results.push(c);
      while (c = this.$expect('CHAR')) {
        results.push(c);
      }
      return new ConstantExpression(results);
    };

    Parser.prototype.$readExpressionBranch = function() {
      var a, expr, pipe;
      if (a = this.$readExpressionList()) {
        expr = new ExpressionBranch;
        expr.items.push(a);
        while (pipe = this.$expect('|')) {
          if (a = this.$readExpressionList()) {
            expr.items.push(a);
          } else {
            expr.items.push(new ConstantExpression);
          }
        }
        return expr;
      }
    };

    Parser.prototype.$readExpressionList = function() {
      var a, expr;
      if (a = this.$readExpression()) {
        expr = new ExpressionList;
        expr.items.push(a);
        while (a = this.$readExpression()) {
          expr.items.push(a);
        }
        return expr;
      }
    };

    Parser.prototype.$readGroupExpression = function() {
      var exp;
      if (!this.$expect('(')) {
        return;
      }
      if (!(exp = this.$readExpressionBranch())) {
        throw this.$invalidToken();
      }
      if (!this.$expect(')')) {
        throw this.$invalidToken();
      }
      return exp;
    };

    Parser.prototype.$readNamedExpression = function() {
      var a, expr;
      if (!this.$expect('<')) {
        return;
      }
      if (!(a = this.$expect('CHAR'))) {
        throw this.$invalidToken();
      }
      expr = new NameLookupExpression;
      expr.name = a.val;
      while (a = this.$expect('CHAR') || this.$expect('ALTCHAR')) {
        expr.name += a.val;
      }
      if (!this.$expect('>')) {
        throw this.$invalidToken();
      }
      return expr;
    };

    Parser.prototype.$readRangeExpression = function() {
      var max, min;
      if (!this.$expect('[')) {
        return;
      }
      if (!(min = this.$expect('CHAR'))) {
        throw this.$invalidToken();
      }
      if (!this.$expect('-')) {
        throw this.$invalidToken();
      }
      if (!(max = this.$expect('CHAR'))) {
        throw this.$invalidToken();
      }
      if (!this.$expect(']')) {
        throw this.$invalidToken();
      }
      return new RangeExpression(min.val[0], max.val[0]);
    };

    Parser.prototype.$readRepeatExpression = function() {
      var max, min;
      if (!this.$expect('{')) {
        return;
      }
      if (!(min = this.$expect('INT'))) {
        throw this.$invalidToken();
      }
      max = min;
      if (this.$expect('-')) {
        if (!(max = this.$expect('INT'))) {
          throw this.$invalidToken();
        }
      }
      if (!this.$expect('}')) {
        throw this.$invalidToken();
      }
      return {
        min: parseInt(min.val),
        max: parseInt(max.val)
      };
    };

    return Parser;

  })();

  this.Parser_v3 = {
    Lexer: Lexer,
    Parser: Parser
  };

}).call(this);
